////////////////////////////////////////////////////////////////////////////////
// Подсистема "Сервис криптографии".
//  
////////////////////////////////////////////////////////////////////////////////


#Область ПрограммныйИнтерфейс

// Шифрует данные для заданного списка получателей.
//
// Параметры:
//   Данные - ДвоичныеДанные, Строка, Массив - один или несколько файлов, которые необходимо зашифровать.
//                                             Двоичные данные или адрес во временном хранилище файла данных,
//                                     		   который необходимо зашифровать.
//
//   Получатели - ДвоичныеДанные - файлов сертификатов 
//              - Структура, ФиксированнаяСтруктура - параметры для поиска сертификатов в хранилище:
//			       * Отпечаток     - ДвоичныеДанные, Строка - отпечаток сертификата,
//			       или
//				   * СерийныйНомер - ДвоичныеДанные, Строка - серийный номер сертификата,
//			       * Издатель      - Структура, ФиксированнаяСтруктура, Строка - свойства издателя 
//			       или  
//			       * Сертификат    - ДвоичныеДанные - файл сертификата.
//				- Массив, ФиксированныйМассив - сертификаты получателей зашифрованного сообщения.
//
//   ТипШифрования - Строка - тип шифрования. Поддерживается только CMS.
//
//   ПараметрыШифрования - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры шифрования.
//
// Возвращаемое значение:
//	 ДвоичныеДанные, Строка - зашифрованные данные. Если данные переданы через временное хранилище,
//                            то и результат будет возвращен также.
//
Функция Зашифровать(Данные, Получатели, ТипШифрования = "CMS", ПараметрыШифрования = Неопределено) Экспорт
	
	Попытка
		ЗашифроватьПроверкаВходящихПараметров(
			Данные, 
			Получатели, 
			ТипШифрования, 
			ПараметрыШифрования);
			
		ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(Данные);
		ВернутьРезультатКакМассив = ТипЗнч(Данные) = Тип("Массив");
		Данные = СервисКриптографииСлужебный.ИзвлечьДвоичныеДанныеПриНеобходимости(Данные);			
		
		Если Не ВернутьРезультатКакМассив Тогда 
			Данные = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Данные);
		КонецЕсли;
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("data", Данные);
		ПараметрыМетода.Вставить("certificates", ПолучитьДвоичныеДанныеСертификатов(Получатели));
		
		Результат = ВыполнитьМетодКриптосервиса("crypto/encryptor", ПараметрыМетода);
	Исключение
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("Получатели", Получатели);
		Параметры.Вставить("ТипШифрования", ТипШифрования);
		Параметры.Вставить("ПараметрыШифрования", ПараметрыШифрования);
		
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияШифрование(), ИнформацияОбОшибке(), Параметры);
		ВызватьИсключение;
	КонецПопытки;
	
	Если ВернутьРезультатКакАдрес Тогда
		Для Индекс = 0 По Результат.ВГраница() Цикл
			Результат[Индекс] = ПоместитьВоВременноеХранилище(Результат[Индекс], Новый УникальныйИдентификатор);
		КонецЦикла;
	КонецЕсли;
	Если Не ВернутьРезультатКакМассив И Результат.Количество() = 1 Тогда
		Результат = Результат[0];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Шифрует блок данных для получателя.
//
// Параметры:
//   Данные - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла данных,
//                                     который необходимо зашифровать.
//
//   Получатель - ДвоичныеДанные - файлов сертификатов 
//              - Структура, ФиксированнаяСтруктура - параметры для поиска сертификатов в хранилище:
//				   * Отпечаток     - ДвоичныеДанные, Строка - отпечаток сертификат.
//				   или
//				   * СерийныйНомер - ДвоичныеДанные, Строка - серийный номер сертификата.
//				   * Издатель      - Структура, ФиксированнаяСтруктура, Строка - свойства издателя
//				   или
//				   * Сертификат    - ДвоичныеДанные - файл сертификата.
//
// Возвращаемое значение:
//	 ДвоичныеДанные, Строка - зашифрованные данные. Если данные переданы через временное хранилище,
//                            то и результат будет возвращен также.
//
Функция ЗашифроватьБлок(Данные, Получатель) Экспорт
	
	Попытка
		ЗашифроватьБлокПроверкаВходящихПараметров(
			Данные, 
			Получатель);
			
		ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(Данные);
		Данные = СервисКриптографииСлужебный.ИзвлечьДвоичныеДанныеПриНеобходимости(Данные);			
	
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("certificate", ПолучитьДвоичныеДанныеСертификата(Получатель));
		ПараметрыМетода.Вставить("data", Данные);
				
		Результат = ВыполнитьМетодКриптосервиса("crypto/encryptor_block", ПараметрыМетода);
	Исключение
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("Получатель", Получатель);
				
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияШифрованиеБлока(), ИнформацияОбОшибке(), Параметры);
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		Результат.ephemeral_key = Base64Значение(Результат.ephemeral_key);
		Результат.iv_data = Base64Значение(Результат.iv_data);
		Результат.session_key = Base64Значение(Результат.session_key);	
	Исключение
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("Получатель", Получатель);
				
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияШифрованиеБлока(), ИнформацияОбОшибке(), Параметры);
		ВызватьИсключение;
	КонецПопытки;
	
	Если ВернутьРезультатКакАдрес Тогда
		Результат = ПоместитьВоВременноеХранилище(Результат, Новый УникальныйИдентификатор);
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Выполняет расшифровку данных.
//
// Параметры:
//   ЗашифрованныеДанные - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла данных,
//                                                  который необходимо расшифровать.
//
//   Сертификат - Структура - сертификат, который необходимо использовать для расшифровки:
//     * Идентификатор - Строка - идентификатор сертификата.
//
//   ТипШифрования - Строка - поддерживается только CMS.
//
//   ПараметрыШифрования - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры шифрования:
//     * ИспользоватьДлительныйМаркерБезопасности - Булево - Если Истина, то для расшифровки можно использовать длительный маркер безопасности.
//                                                           Ложь - значение по умолчанию.
//
// Возвращаемое значение:
//	 ДвоичныеДанные - расшифрованные данные,
//   Строка - расшифрованные данные, если данные переданы через временное хранилище,
//	 Структура - Описание ошибки выполнения:
//     * КодВозврата - Строка - код ошибки.
//     * Идентификатор - Строка - идентификатор сертификата.
//
Функция Расшифровать(ЗашифрованныеДанные, Сертификат, ТипШифрования = "CMS", ПараметрыШифрования = Неопределено) Экспорт

	Попытка
		РасшифроватьПроверкаВходящихПараметров(
			ЗашифрованныеДанные, 
			ТипШифрования, 
			ПараметрыШифрования);

		ИспользоватьДлительныйМаркерБезопасности = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
			ПараметрыШифрования, "ИспользоватьДлительныйМаркерБезопасности", Ложь);

		МаркерыБезопасности = МаркерыБезопасности(Сертификат.Идентификатор, ИспользоватьДлительныйМаркерБезопасности);

		Если Не ЗначениеЗаполнено(МаркерыБезопасности.МаркерБезопасности)
			И Не ЗначениеЗаполнено(МаркерыБезопасности.ДлительныйМаркерБезопасности) Тогда
			Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Сертификат.Идентификатор);
		КонецЕсли;

		ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(ЗашифрованныеДанные);
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("data", ЗашифрованныеДанные);
		ПараметрыМетода.Вставить("security_token", МаркерыБезопасности.МаркерБезопасности);
		ПараметрыМетода.Вставить("long_security_token", МаркерыБезопасности.ДлительныйМаркерБезопасности);
		
		Результат = ВыполнитьМетодКриптосервиса("crypto/decryptor", ПараметрыМетода);
		
		Если НЕ ЗначениеЗаполнено(Результат) Тогда
			ВызватьИсключение(НСтр("ru = 'Не удалось выполнить расшифровку сообщения'"));
		КонецЕсли;
		
		Если ВернутьРезультатКакАдрес Тогда
			Результат = ПоместитьВоВременноеХранилище(Результат, Новый УникальныйИдентификатор);
		КонецЕсли;
		
		Возврат Результат;
		
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстИсключения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Если СтрНайти(ТекстИсключения, "InvalidSecurityTokenError") Тогда
			Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Сертификат.Идентификатор);
		КонецЕсли;
		
		Параметры = Новый Структура;
		Параметры.Вставить("ЗашифрованныеДанные", ЗашифрованныеДанные);
		Параметры.Вставить("Сертификат", Сертификат);
		Параметры.Вставить("ТипШифрования", ТипШифрования);
		Параметры.Вставить("ПараметрыШифрования", ПараметрыШифрования);
	
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияРасшифровка(), ИнформацияОбОшибке, Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Выполняет расшифровку данных перебором сертификатов из криптосообщения.
//
// Параметры:
//   ЗашифрованныеДанные - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла данных,
//                                                  который необходимо расшифровать.
//
//   ТипШифрования - Строка - поддерживается только CMS.
//
//   ПараметрыШифрования - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры шифрования.
//     * ИспользоватьДлительныйМаркерБезопасности - Булево - Если Истина, то для расшифровки можно использовать длительный маркер безопасности.
//                                                           Ложь - значение по умолчанию.
//
// Возвращаемое значение:
//	 ДвоичныеДанные, Строка - расшифрованные данные. Если данные переданы через временное хранилище,
//                            то и результат будет возвращен также.
//   Структура - Описание ошибки выполнения.
//     * КодВозврата - Строка - код ошибки.
//     * Идентификатор - Строка - идентификатор сертификата.
//
Функция РасшифроватьПереборомСертификатов(ЗашифрованныеДанные, ТипШифрования = "CMS", ПараметрыШифрования = Неопределено) Экспорт

	ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(ЗашифрованныеДанные);

	Криптосообщение = СервисКриптографииСлужебный.ИзвлечьДвоичныеДанныеПриНеобходимости(ЗашифрованныеДанные);

	СвойстваСообщения = ПолучитьСвойстваКриптосообщения(Криптосообщение, Истина);
	
	Идентификаторы = Новый Массив;
	Если СвойстваСообщения.Тип = "envelopedData" Тогда
		Получатели = СвойстваСообщения.Получатели; // см. ПолучитьСвойстваСертификатовИзJson
		Для Каждого Получатель Из Получатели Цикл 
			Если Получатель.Свойство("Идентификатор") Тогда 
				Идентификаторы.Добавить(Получатель.Идентификатор);
			КонецЕсли;
		КонецЦикла;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Недопустимое значение параметра ЗашифрованныеДанные - файл не является криптосообщением'"));
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Идентификаторы) Тогда
		ВызватьИсключение(НСтр("ru = 'В хранилище отсутствуют сертификаты для расшифровки сообщения.'"));
	КонецЕсли;
	
	Идентификаторы = СервисКриптографииСлужебный.ОпределитьПорядокСертификатов(Идентификаторы);

	РасшифрованныеДанные = Неопределено;

	Для каждого ТекущийИдентификатор Из Идентификаторы Цикл

		Попытка
			Сертификат = Новый Структура("Идентификатор", ТекущийИдентификатор);
			РасшифрованныеДанные = Расшифровать(Криптосообщение, Сертификат, ТипШифрования, ПараметрыШифрования);
		Исключение
			// Запись в журнале регистрации не требуется.
			// При расшифровке могла возникнуть ошибка, если сертификат был неподходящий, тогда пробуем следующий по списку.
		КонецПопытки;

		Если РасшифрованныеДанные <> Неопределено Тогда
			// Если расшифровка прошла успешно или возникла ошибка, препятствующая дальнейшему выполнению, то прекращаем перебор сертификатов.
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТипЗнч(РасшифрованныеДанные) = Тип("Структура") Тогда
		// Особая ошибка сервиса криптографии, прекращаем выполнение и передаем информацию о ней вызывающему методу.
		Возврат РасшифрованныеДанные;
	КонецЕсли;
	
	Если ВернутьРезультатКакАдрес Тогда
		РасшифрованныеДанные = ПоместитьВоВременноеХранилище(РасшифрованныеДанные, Новый УникальныйИдентификатор);
	КонецЕсли;
	
	Возврат РасшифрованныеДанные;

КонецФункции

// Выполняет расшифровку блока данных.
//
// Параметры:
//   ЗашифрованныеДанные - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла данных,
//                                                  который необходимо расшифровать.
//
//   Получатель - ДвоичныеДанные - файл сертификата получателя зашифрованного сообщения
//              - Структура, ФиксированнаяСтруктура - параметры для поиска сертификатов в хранилище:
//                 * Идентификатор - Строка - идентификатор сертификата.
//
//   КлючеваяИнформация - Структура, ФиксированнаяСтруктура - позволяет передать данные о ключах шифрования в запрос:
//       * ephemeral_key - ДвоичныеДанные, Строка - в base64, эфемерный ключ
//       * session_key - ДвоичныеДанные, Строка - в base64, сессионный ключ
//       * iv_data - ДвоичныеДанные, Строка - в base64, данные вектора инициализации
//
//   ПараметрыШифрования - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры шифрования.
//
// Возвращаемое значение:
//	 ДвоичныеДанные - расшифрованные данные;
//	 Строка - расшифрованные данные, если данные переданы через временное хранилище;
//   Структура - описание ошибки выполнения:
//     * КодВозврата - Строка - код ошибки.
//     * Идентификатор - Строка - идентификатор сертификата.
//
Функция РасшифроватьБлок(ЗашифрованныеДанные, Получатель, КлючеваяИнформация, ПараметрыШифрования = Неопределено) Экспорт
	
	Попытка
		РасшифроватьБлокПроверкаВходящихПараметров(
			ЗашифрованныеДанные, 
			Получатель,
			КлючеваяИнформация, 
			ПараметрыШифрования);
			
		ИспользоватьДлительныйМаркерБезопасности = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
			ПараметрыШифрования, "ИспользоватьДлительныйМаркерБезопасности", Ложь);
			
		Сертификат = НайтиСертификат(Получатель);
		Если Не ЗначениеЗаполнено(Сертификат) Тогда
			ВызватьИсключение(НСтр("ru = 'Сертификат подписанта не найден в хранилище сертификатов.'"));
		КонецЕсли;
		
		МаркерыБезопасности = МаркерыБезопасности(Сертификат.Идентификатор, ИспользоватьДлительныйМаркерБезопасности);

		Если Не ЗначениеЗаполнено(МаркерыБезопасности.МаркерБезопасности)
			И Не ЗначениеЗаполнено(МаркерыБезопасности.ДлительныйМаркерБезопасности) Тогда
			Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Сертификат.Идентификатор);
		КонецЕсли;
						
		clear_padding = Истина;
		Если ЗначениеЗаполнено(ПараметрыШифрования) Тогда 
			ПараметрыШифрования.Свойство("ОчиститьДополняющиеБайты", clear_padding);
			clear_padding = ?(ТипЗнч(clear_padding) = Тип("Булево"), clear_padding, Истина);
		КонецЕсли;		
		
		ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(ЗашифрованныеДанные);
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("security_token", МаркерыБезопасности.МаркерБезопасности);
		ПараметрыМетода.Вставить("long_security_token", МаркерыБезопасности.ДлительныйМаркерБезопасности);
		ПараметрыМетода.Вставить("data", ЗашифрованныеДанные);
		ПараметрыМетода.Вставить("ephemeral_key", 
			СервисКриптографииСлужебный.ДвоичныеДанныеВBase64ПриНеобходимости(КлючеваяИнформация.ephemeral_key));
		ПараметрыМетода.Вставить("session_key", 
			СервисКриптографииСлужебный.ДвоичныеДанныеВBase64ПриНеобходимости(КлючеваяИнформация.session_key));
		ПараметрыМетода.Вставить("iv_data", 
			СервисКриптографииСлужебный.ДвоичныеДанныеВBase64ПриНеобходимости(КлючеваяИнформация.iv_data));
		ПараметрыМетода.Вставить("clear_padding", clear_padding);
		
		Результат = ВыполнитьМетодКриптосервиса("crypto/decryptor_block", ПараметрыМетода);
		
		Если НЕ ЗначениеЗаполнено(Результат) Тогда
			ВызватьИсключение(НСтр("ru = 'Не удалось выполнить расшифровку блока данных'"));
		КонецЕсли;
		
		Если ВернутьРезультатКакАдрес Тогда
			Результат = ПоместитьВоВременноеХранилище(Результат, Новый УникальныйИдентификатор);
		КонецЕсли;
		
		Возврат Результат;
		
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстИсключения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Если СтрНайти(ТекстИсключения, "InvalidSecurityTokenError") Тогда
			Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Получатель.Идентификатор);
		КонецЕсли;
		
		Параметры = Новый Структура;
		Параметры.Вставить("ЗашифрованныеДанные", ЗашифрованныеДанные);
		Параметры.Вставить("Получатель", Получатель);
		Параметры.Вставить("КлючеваяИнформация", КлючеваяИнформация);
		Параметры.Вставить("ПараметрыШифрования", ПараметрыШифрования);
	
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияРасшифровкаБлока(), ИнформацияОбОшибке, Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Выполняет подписание данных.
//
// Параметры:
//   Данные - ДвоичныеДанные, Строка, Массив - один или несколько файлов, которые необходимо подписать. 
//                                             Двоичные данные или адрес во временном хранилище файла данных,
//                                             который необходимо подписать.
//
//   Подписант - ДвоичныеДанные - файла сертификата для подписания. 
//             - Структура, ФиксированнаяСтруктура - параметры для поиска сертификата в хранилище.
//		          * Отпечаток     - ДвоичныеДанные, Строка - отпечаток сертификат.
//		          или
//		          * СерийныйНомер - ДвоичныеДанные, Строка - серийный номер сертификата.
//		          * Издатель      - Структура, ФиксированнаяСтруктура, Строка - свойства издателя.
//		          или
//		          * Сертификат    - ДвоичныеДанные - файл сертификата.
//
//   ТипПодписи - Строка - тип подписи. Поддерживаются только "CMS" или "GOST3410".
//
//   ПараметрыПодписания - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры подписания:
//     * ОтсоединеннаяПодпись - Булево - поддерживается только CMS, если Истина, то будет сформирована отсоединенная подпись, иначе - присоединенная.
//                                       Истина - значение по умолчанию.
//     * ИспользоватьДлительныйМаркерБезопасности - Булево - Если Истина, то для расшифровки можно использовать длительный маркер безопасности.
//                                                           Ложь - значение по умолчанию.
//
// Возвращаемое значение:
//	 ДвоичныеДанные - подпись; 
//	 Строка - подпись, если данные переданы через временное хранилище;
//   Структура - описание ошибки выполнения:
//     * КодВозврата - Строка - код ошибки.
//     * Идентификатор - Строка - идентификатор сертификата.
//
Функция Подписать(Данные, Подписант, ТипПодписи = "CMS", ПараметрыПодписания = Неопределено) Экспорт

	ПодписатьПроверкаВходящихПараметров(
		Данные, 
		Подписант, 
		ТипПодписи, 
		ПараметрыПодписания);

	ИспользоватьДлительныйМаркерБезопасности = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(
		ПараметрыПодписания, "ИспользоватьДлительныйМаркерБезопасности", Ложь);
	
	Сертификат = НайтиСертификат(Подписант);
	Если Не ЗначениеЗаполнено(Сертификат) Тогда
		ВызватьИсключение(НСтр("ru = 'Сертификат подписанта не найден в хранилище сертификатов.'"));
	КонецЕсли;
	
	МаркерыБезопасности = МаркерыБезопасности(Сертификат.Идентификатор, ИспользоватьДлительныйМаркерБезопасности);
	
	Если Не ЗначениеЗаполнено(МаркерыБезопасности.МаркерБезопасности)
		И Не ЗначениеЗаполнено(МаркерыБезопасности.ДлительныйМаркерБезопасности) Тогда
		Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Сертификат.Идентификатор);
	КонецЕсли;
	
	ВернутьРезультатКакАдрес = СервисКриптографииСлужебный.ВернутьРезультатКакАдресВоВременномХранилище(Данные);
	ВернутьРезультатКакМассив = ТипЗнч(Данные) = Тип("Массив");
		
	Попытка
		Если ЗначениеЗаполнено(ПараметрыПодписания) 
			И ПараметрыПодписания.Свойство("ОтсоединеннаяПодпись") Тогда
			ОтсоединеннаяПодпись = ПараметрыПодписания.ОтсоединеннаяПодпись;
		Иначе
			ОтсоединеннаяПодпись = Истина;
		КонецЕсли;
		
		Если Не ВернутьРезультатКакМассив Тогда 
			Данные = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Данные);
		КонецЕсли;
	
	    ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("security_token",      МаркерыБезопасности.МаркерБезопасности);
		ПараметрыМетода.Вставить("long_security_token", МаркерыБезопасности.ДлительныйМаркерБезопасности);
		ПараметрыМетода.Вставить("data",                Данные);
		ПараметрыМетода.Вставить("type",                ТипПодписи);
		ПараметрыМетода.Вставить("include_data",        Не ОтсоединеннаяПодпись);
		
		Результат = ВыполнитьМетодКриптосервиса("crypto/signature", ПараметрыМетода);
		
		Если ВернутьРезультатКакАдрес Тогда
			Для Индекс = 0 По Результат.ВГраница() Цикл
				Результат[Индекс] = ПоместитьВоВременноеХранилище(Результат[Индекс], Новый УникальныйИдентификатор);
			КонецЦикла;
		КонецЕсли;
		Если Не ВернутьРезультатКакМассив И Результат.Количество() = 1 Тогда
			Результат = Результат[0];
		КонецЕсли;
		
		Возврат Результат;
		
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ТекстИсключения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Если СтрНайти(ТекстИсключения, "InvalidSecurityTokenError") Тогда
			Возврат Новый Структура("КодВозврата, Идентификатор", "ТребуетсяАутентификация", Сертификат.Идентификатор);
		КонецЕсли;
		
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("Подписант", Подписант);
		Параметры.Вставить("ТипПодписи", ТипПодписи);
		Параметры.Вставить("ПараметрыПодписания", ПараметрыПодписания);
	
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияПодписание(), ИнформацияОбОшибке, Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Выполняет проверку подписи.
//
// Параметры:
//   Подпись - ДвоичныеДанные - подпись, которую необходимо проверить.
//
//   Данные - ДвоичныеДанные - исходные данные, необходимые для проверки подписи. Используется для проверки ОтсоединеннаяПодпись.
//
//   ТипПодписи - Строка - тип подписи. Поддерживаются только "CMS" или "GOST3410".
//
//   ПараметрыПодписания - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры подписания.
//     * ОтсоединеннаяПодпись - Булево - используется совместно с ТипПодписи = "CMS", если Истина, то подпись будет проверяться с использованием Данные.
//                                       Истина - значение по умолчанию.
//     * Сертификат - ДвоичныеДанные - файл сертификата, обязательно используется совместно с ТипПодписи = "GOST3410".
//
// Возвращаемое значение:
//	 Булево - если Истина, то подпись действительна.
//
Функция ПроверитьПодпись(Подпись, Данные = Неопределено, ТипПодписи = "CMS", ПараметрыПодписания = Неопределено) Экспорт
	
	ПроверитьПодписьПроверкаВходящихПараметров(
		Подпись, 
		Данные, 
		ТипПодписи, 
		ПараметрыПодписания);
	
	Попытка
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("signature", Подпись);
		ПараметрыМетода.Вставить("data", Данные);
		ПараметрыМетода.Вставить("type", ТипПодписи);
		
		Если ТипПодписи = "GOST3410" Тогда
			ПараметрыМетода.Вставить("certificate", ПараметрыПодписания.Сертификат);
		КонецЕсли;
		
		Возврат ВыполнитьМетодКриптосервиса("crypto/verification/signature", ПараметрыМетода);
		
	Исключение
		
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("Подпись", Подпись);
		Параметры.Вставить("ТипПодписи", ТипПодписи);
		Параметры.Вставить("ПараметрыПодписания", ПараметрыПодписания);
	
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияПроверкаПодписи(), ИнформацияОбОшибке(), Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

//  Выполняет расчет хеш-суммы по переданным данным.
//
// Параметры:
//   Данные - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла данных,
//                                     от которых необходимо посчитать хеш-сумму.
//   АлгоритмХеширования - Строка - константа из списка "GOST R 34.11-94", "GOST R 34.11-2012 256", "GOST R 34.11-2012 512".
//
//   ПараметрыХеширования - Структура, ФиксированнаяСтруктура - позволяет указать дополнительные параметры хеширования.
//     * ИнвертироватьПолубайты - Булево - управляет инвертированием полубайт в значении хеш-суммы. Применяется только для "GOST R 34.11-94"
//                                Например, прямой порядок - 62 FB, обратный - 26 BF.
//                                Истина - значение по умолчанию.
//
// Возвращаемое значение:
//	 ДвоичныеДанные - значение хеш-суммы.
//
Функция ХешированиеДанных(Данные, АлгоритмХеширования = "GOST R 34.11-94", ПараметрыХеширования = Неопределено) Экспорт
	
	ХешированиеДанныхПроверкаВходящихПараметров(
		Данные, 
		АлгоритмХеширования, 
		ПараметрыХеширования);
	
	Попытка
		Если ЗначениеЗаполнено(ПараметрыХеширования) 
			И ПараметрыХеширования.Свойство("ИнвертироватьПолубайты") Тогда
			ИнвертироватьПолубайты = ПараметрыХеширования.ИнвертироватьПолубайты;
		Иначе
			ИнвертироватьПолубайты = Истина;
		КонецЕсли;
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("data", Данные);
		ПараметрыМетода.Вставить("algorithm", АлгоритмХеширования);
		ПараметрыМетода.Вставить("inverted_halfbytes", ИнвертироватьПолубайты);
		
		Возврат ВыполнитьМетодКриптосервиса("crypto/hash", ПараметрыМетода);
		
	Исключение
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		
		Параметры = Новый Структура;
		Параметры.Вставить("Данные", Данные);
		Параметры.Вставить("АлгоритмХеширования", АлгоритмХеширования);
		Параметры.Вставить("ПараметрыХеширования", ПараметрыХеширования);
	
		ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияХеширование(), ИнформацияОбОшибке, Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Выполняет проверку сертификата.
//
// Параметры:
//   Сертификат - ДвоичныеДанные - файл сертификата.
//
// Возвращаемое значение:
//	 Булево - если Истина, то сертификат действителен.
//
Функция ПроверитьСертификат(Сертификат) Экспорт
	
	ПроверитьСертификатПроверкаВходящихПараметров(Сертификат);
	
	Попытка
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("certificate", ХранилищеСертификатов.СертификатВКодировкеDER(Сертификат));
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/verification/certificate", ПараметрыМетода);
		
		Возврат Результат;
	Исключение
		Параметры = Новый Структура("Сертификат", Сертификат);
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияПроверкаСертификата(), ИнформацияОбОшибке(), Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Неопределено;
		
КонецФункции

// Выполняет проверку сертификата с дополнительными параметрами
//
// Параметры:
//   Сертификат - ДвоичныеДанные - файл сертификата.
//   ПараметрыПроверки - Структура - содержит дополнительные параметры проверки.
//		* РежимПроверкиСертификата - Строка - обрабатываются варианты "ИгнорироватьВремяДействия",
//												"ИгнорироватьДействительностьПодписи", 
//												"ИгнорироватьПроверкуВСпискеОтозванныхСертификатов",
//												"РазрешитьТестовыеСертификаты"
//
// Возвращаемое значение:
//	 Булево - если Истина, то сертификат действителен.
//
Функция ПроверитьСертификатСПараметрами(Сертификат, ПараметрыПроверки) Экспорт
	
	ПроверитьСертификатПроверкаВходящихПараметров(Сертификат);
	
	Попытка
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("certificate", ХранилищеСертификатов.СертификатВКодировкеDER(Сертификат));
		
		РежимПроверкиСертификата = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ПараметрыПроверки, "РежимПроверкиСертификата", "");
		Если ЗначениеЗаполнено(РежимПроверкиСертификата) Тогда
			ПараметрыМетода.Вставить("mode", ПодготовитьРежимыПроверкиСертификата(РежимПроверкиСертификата));
		КонецЕсли;
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/verification/certificate", ПараметрыМетода);
		
		Возврат Результат;
	Исключение
		Параметры = Новый Структура("Сертификат", Сертификат);
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияПроверкаСертификата(), ИнформацияОбОшибке(), Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Неопределено;
		
КонецФункции

// Получает основные свойства переданного сертификата.
// 
// Параметры:
//   Сертификат - ДвоичныеДанные - сертификат, свойства которого необходимо получить.
//
// Возвращаемое значение:
//	 ФиксированнаяСтруктура - свойства сертификата:
//    * Версия - Строка - версия сертификата.
//    * ДатаНачала - Дата - дата начала действия сертификата (UTC).
//    * ДатаОкончания - Дата - дата окончания действия сертификата (UTC).
//    * Издатель - ФиксированнаяСтруктура - информация об издателе сертификата:
//        ** CN - Строка - commonName 
//        ** O - Строка - organizationName; 
//        ** OU - Строка - organizationUnitName; 
//        ** C - Строка - countryName; 
//        ** ST - Строка - stateOrProvinceName; 
//        ** L - Строка - localityName; 
//        ** E - Строка - emailAddress; 
//        ** SN - Строка - surname; 
//        ** GN - Строка - givenName; 
//        ** T - Строка - title;
//        ** STREET - Строка - streetAddress;
//        ** OGRN - Строка - ОГРН;
//        ** OGRNIP - Строка - ОГРНИП;
//        ** INN - Строка - ИНН (не обязательный);
//        ** INNLE - Строка - ИНН ЮЛ (не обязательный);
//        ** SNILS - Строка - СНИЛС;
//           ...
//    * ИспользоватьДляПодписи - Булево - указывает, можно ли использовать данный сертификат для подписи.
//    * ИспользоватьДляШифрования - Булево - указывает, можно ли использовать данный сертификат для шифрования.
//    * ОткрытыйКлюч - ДвоичныеДанные - содержит данные открытого ключа.
//    * Отпечаток - ДвоичныеДанные - содержит данные отпечатка. Вычисляется динамически, по алгоритму SHA-1.
//    * РасширенныеСвойства - ФиксированнаяСтруктура -  расширенные свойства сертификата:
//        ** EKU - ФиксированныйМассив из Произвольный - Enhanced Key Usage.
//    * СерийныйНомер - ДвоичныеДанные - серийный номер сертификата.
//    * Субъект - ФиксированнаяСтруктура - информацию о субъекте сертификата. Состав см. Издатель:
//        ** CN - Строка - commonName ...
//    * Сертификат - ДвоичныеДанные - файл сертификата в кодировке DER.
//    * Идентификатор - Строка - вычисляется по ключевым свойствам Издателя и серийному номеру по алгоритму SHA1.
//                               Используется для идентификации сертификата в сервисе криптографии.
//
Функция ПолучитьСвойстваСертификата(Сертификат) Экспорт
	
	ПолучитьСвойстваСертификатаПроверкаВходящихПараметров(Сертификат);
	
	Попытка
		СертификатВКодировкеDER = ХранилищеСертификатов.СертификатВКодировкеDER(Сертификат);
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("certificate", СертификатВКодировкеDER);
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/certificate", ПараметрыМетода);
		
		Свойства = Новый Структура;
		Свойства.Вставить("Версия"                   , СтрШаблон("V%1", Результат.version + 1));
		Свойства.Вставить("ДатаНачала"            	 , XMLЗначение(Тип("Дата"), Лев(Результат.valid_from, 19)));
		Свойства.Вставить("ДатаОкончания"            , XMLЗначение(Тип("Дата"), Лев(Результат.valid_to, 19)));
		Свойства.Вставить("Издатель"                 , ПреобразоватьOID(Результат.issuer));
		Свойства.Вставить("ИспользоватьДляПодписи"   , Результат.use_to_sign);
		Свойства.Вставить("ИспользоватьДляШифрования", Результат.use_to_encrypt);
		Свойства.Вставить("ОткрытыйКлюч"             , Результат.public_key);
		Свойства.Вставить("Отпечаток"                , Результат.thumbprint);
		Свойства.Вставить("РасширенныеСвойства"      , РасширенныеСвойстваСертификата(Результат.extensions));
		Свойства.Вставить("СерийныйНомер"            , Результат.serial_number);
		Свойства.Вставить("Субъект"                  , ПреобразоватьOID(Результат.subject));
		Свойства.Вставить("Наименование"             , НаименованиеСертификата(Результат.subject));
		Свойства.Вставить("Сертификат"               , СертификатВКодировкеDER);
		Свойства.Вставить("Идентификатор"            , ВычислитьИдентификаторСертификатаJson(Результат));
		
		Возврат Новый ФиксированнаяСтруктура(Свойства);
	
	Исключение
		Параметры = Новый Структура("Сертификат", Сертификат);
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияСвойстваСертификата(), ИнформацияОбОшибке(), Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
		
КонецФункции

// Извлекает массив сертификатов из данных подписи.
//
// Параметры:
//   Подпись - ДвоичныеДанные - файл подписи.
//
// Возвращаемое значение:
//	 Массив из ФиксированнаяСтруктура - со свойствами сертификатов:
//    * Издатель - ФиксированнаяСтруктура - информация об издателе сертификата:
//        ** CN - Строка - commonName; 
//        ** O - Строка - organizationName; 
//        ** OU - Строка - organizationUnitName; 
//        ** C - Строка - countryName; 
//        ** ST - Строка - stateOrProvinceName; 
//        ** L - Строка - localityName; 
//        ** E - Строка - emailAddress; 
//        ** SN - Строка - surname; 
//        ** GN - Строка - givenName; 
//        ** T - Строка - title;
//        ** STREET - Строка - streetAddress;
//        ** OGRN - Строка - ОГРН;
//        ** OGRNIP - Строка - ОГРНИП;
//        ** INN - Строка - ИНН;
//        ** INNLE - Строка - ИНН ЮЛ (не обязательный);
//        ** SNILS - Строка - СНИЛС;
//    * СерийныйНомер - ДвоичныеДанные - серийный номер сертификата.
//    * Сертификат - ДвоичныеДанные - файл сертификата в кодировке DER.
//    * Идентификатор - Строка - вычисляется по ключевым свойствам Издателя и серийному номеру по алгоритму SHA1.
//                               Используется для идентификации сертификата в сервисе криптографии.
//
Функция ПолучитьСертификатыИзПодписи(Подпись) Экспорт
	
	ПолучитьСертификатыИзПодписиПроверкаВходящихПараметров(Подпись);
	
	Если ТипЗнч(Подпись) = Тип("Строка") Тогда
		Подпись = ПолучитьИзВременногоХранилища(Подпись);
	КонецЕсли;
	
	СвойстваКриптосообщения = ПолучитьСвойстваКриптосообщения(Подпись);
	Если СвойстваКриптосообщения.Тип = "signedData" Тогда
		Возврат СвойстваКриптосообщения.Сертификаты;	
	Иначе
		ВызватьИсключение(НСтр("ru = 'Параметр <Подпись> не является файлом подписи'"));
	КонецЕсли;
	
КонецФункции

// Извлекает свойства из файла криптосообщения.
//
// Параметры:
//   Криптосообщение - ДвоичныеДанные, Строка - двоичные данные или адрес во временном хранилище файла криптосообщения.
//   ТолькоКлючевыеСвойства - Булево - если Истина, то Содержимое будет возвращаться всегда пустое.
//
// Возвращаемое значение:
// 	Структура - свойства криптосообщения:
// 	 * Размер - Число - размер файла в байтах.
// 	 * Тип - Строка - указывает тип сообщения: envelopedData, signedData, unknown.
// 	 * Получатели - ФиксированныйМассив Из Структура - описание сертификатов получателей зашифрованного сообщения. Только для Тип="envelopedData":
//   	** Идентификатор - Строка - вычисляется по ключевым свойствам Издателя и серийному номеру по алгоритму SHA1, 
//   								остальные поля см. ПолучитьСвойстваСертификата.
// 	 * Подписанты - ФиксированныйМассив Из Структура - описание сертификатов получателей зашифрованного сообщения. Только для Тип="signedData":
// 	    ** Идентификатор - Строка - вычисляется по ключевым свойствам Издателя и серийному номеру по алгоритму SHA1.
//   								остальные поля см. ПолучитьСвойстваСертификата.
// 	 * Содержимое - ДвоичныеДанные - содержимое криптосообщения.
//
Функция ПолучитьСвойстваКриптосообщения(Криптосообщение, ТолькоКлючевыеСвойства = Ложь) Экспорт
	
	СвойстваКриптосообщения = Новый Структура;
	СвойстваКриптосообщения.Вставить("Тип", "unknown");
	
	Попытка
		ПолучитьСвойстваКриптосообщенияПроверкаВходящихПараметров(Криптосообщение);
		
		СвойстваКриптосообщения.Вставить("Размер", Криптосообщение.Размер());
		
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("message", Криптосообщение);
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/crypto_message", ПараметрыМетода);
		
		СвойстваКриптосообщения.Вставить("Тип", Результат.type);	
		
		Получатели = ПолучитьСвойстваСертификатовИзJson(Результат.recipient_infos);
		СвойстваКриптосообщения.Вставить("Получатели", Новый ФиксированныйМассив(Получатели));
		
		Подписанты = ПолучитьСвойстваСертификатовИзJson(Результат.signer_infos);
		СвойстваКриптосообщения.Вставить("Подписанты", Новый ФиксированныйМассив(Подписанты));			
		
		Если Не ТолькоКлючевыеСвойства Тогда
			Сертификаты = Новый Массив;
			Для Каждого certificate Из Результат.certificates Цикл
				Сертификаты.Добавить(certificate);		
			КонецЦикла;
			СвойстваКриптосообщения.Вставить("Сертификаты", Новый ФиксированныйМассив(Сертификаты));
			Если Не ЗначениеЗаполнено(Результат.content) Тогда
				Результат.content = Base64Значение("");
			КонецЕсли;
			
			СвойстваКриптосообщения.Вставить("Содержимое", Результат.content);
		КонецЕсли;
	Исключение
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияСвойстваКриптосообщения(), ИнформацияОбОшибке(), СвойстваКриптосообщения);
	КонецПопытки;
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

// Получает возможные способы доставки временных паролей.
//
// Параметры:
//   ИдентификаторСертификата - Строка - идентификатор сертификата, для которого необходимо получить способы доставки паролей.
//
// Возвращаемое значение:
//   Структура - содержит ключи:
//     * Телефон          - Строка - замаскированное представление телефона для получения временных паролей в SMS.
//     * ЭлектроннаяПочта - Строка - замаскированное представление электронной почты для получения временных паролей в письмах.
//
Функция ПолучитьНастройкиПолученияВременныхПаролей(ИдентификаторСертификата) Экспорт
	
	Попытка
		ПараметрыМетода = Новый Структура;
		ПараметрыМетода.Вставить("certificate_id", ИдентификаторСертификата);
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/auth_parameters", ПараметрыМетода);
		
		СпособыДоставкиПаролей = Новый Структура("Телефон,ЭлектроннаяПочта", "", "");
		Для Каждого ЭлементРезультата Из Результат Цикл 
			Если ЭлементРезультата.type = "phone" Тогда
				СпособыДоставкиПаролей.Телефон = ЭлементРезультата.value;
			ИначеЕсли ЭлементРезультата.type = "email" Тогда
				СпособыДоставкиПаролей.ЭлектроннаяПочта = ЭлементРезультата.value;
			КонецЕсли;	
		КонецЦикла;
		
		Возврат СпособыДоставкиПаролей;
	Исключение
		Параметры = Новый Структура("ИдентификаторСертификата", ИдентификаторСертификата);
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияАутентификация(), ИнформацияОбОшибке(), Параметры);
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецФункции

// Запрашивает у сервиса криптографии отправку временного пароля.
//
// Параметры:
//	ИдентификаторСертификата - Строка - Идентификатора сертификата, для которого требуется временный пароль.
//	ПовторнаяОтправка - Булево - Истина, если запрос является повторным.
//	СпособДоставкиПаролей - Строка - Одно из значений: "phone" или "email".
//	ИдентификаторСессии - Строка - идентификатор сессии
//
// Возвращаемое значение:
//	Структура - содержит ключи:
//		* ЗадержкаПередПовторнойОтправкой - Число - Число секунд перед повторным запросом нового пароля.
//		* ВремяДействияПароля - Число - Число секунд, в течение которых действует высланный пароль.
//		* ИдентификаторСессии - Строка - если есть "session_id".
//
Функция ПолучитьВременныйПароль(ИдентификаторСертификата, ПовторнаяОтправка, СпособДоставкиПаролей, ИдентификаторСессии = Неопределено) Экспорт

	РезультатВыполнения = Новый Структура();
	РезультатВыполнения.Вставить("ЗадержкаПередПовторнойОтправкой", 0);
	РезультатВыполнения.Вставить("ВремяДействияПароля",             0);

	ПараметрыМетода = Новый Структура;
	ПараметрыМетода.Вставить("certificate_id", ИдентификаторСертификата);
	ПараметрыМетода.Вставить("repeat",         ПовторнаяОтправка);
	ПараметрыМетода.Вставить("type",           СпособДоставкиПаролей);
	
	Если ЗначениеЗаполнено(ИдентификаторСессии) Тогда
		Заголовки = Новый Соответствие;
		Заголовки.Вставить("X-Auth-Session", ИдентификаторСессии);
	Иначе
		Заголовки = Неопределено;
	КонецЕсли;		
		
	Попытка

		ПолучитьВременныйПарольПроверкаВходящихПараметров(ИдентификаторСертификата, ПовторнаяОтправка, СпособДоставкиПаролей);
		
		Результат = СервисКриптографииСлужебный.ВыполнитьМетодКриптосервиса("crypto/password", ПараметрыМетода, Заголовки);
		
		РезультатВыполнения.ЗадержкаПередПовторнойОтправкой = Результат.delay;
		РезультатВыполнения.ВремяДействияПароля             = Результат.life_time;
		
		Если Результат.Свойство("session_id") Тогда 
			РезультатВыполнения.Вставить("ИдентификаторСессии", Результат.session_id);
		КонецЕсли;
		
	Исключение
		
		СервисКриптографииСлужебный.ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытияАутентификация(), ИнформацияОбОшибке(), ПараметрыМетода);
		ВызватьИсключение;
	
	КонецПопытки;
	
	Возврат РезультатВыполнения;

КонецФункции

// Отправляет сервису криптографии ранее полученный временный пароль и запрашивает маркеры безопасности для него.
//
// Параметры:
//	ИдентификаторСертификата - Строка - Идентификатор сертификата, с помощью которого планируется подписание.
//	ВременныйПароль - Строка - Временный пароль, ранее присланный сервисом криптографии.
//
Процедура ПодтвердитьВременныйПароль(ИдентификаторСертификата, ВременныйПароль) Экспорт

	СервисКриптографииСлужебный.ПодтвердитьВременныйПароль(ИдентификаторСертификата, ВременныйПароль);

КонецПроцедуры

// Пытается получить ранее сохраненные маркеры безопасности: сессионный и долговременный
//
// Параметры:
//	ИдентификаторСертификата - Строка - Идентификатор сертификата, с помощью которого планируется подписание.
//	ИспользоватьДлительныйМаркерБезопасности - Булево - признак поиска долговременного токена.
//	
// Возвращаемое значение:
//	Структура - маркер:
//   * МаркерБезопасности - Строка
//   * ДлительныйМаркерБезопасности - Строка
Функция МаркерыБезопасности(ИдентификаторСертификата, ИспользоватьДлительныйМаркерБезопасности) Экспорт

	Результат = Новый Структура();
	Результат.Вставить("МаркерБезопасности");
	Результат.Вставить("ДлительныйМаркерБезопасности");
	
	УстановитьПривилегированныйРежим(Истина);
	Результат.МаркерБезопасности = ПараметрыСеанса.МаркерыБезопасности.Получить(ИдентификаторСертификата);
	
	Если ИспользоватьДлительныйМаркерБезопасности Тогда 
		Результат.ДлительныйМаркерБезопасности = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(
			СервисКриптографииСлужебный.ИмяНастройкиДлительногоМаркерБезопасностиСертификата(ИдентификаторСертификата),
			"ДлительныйМаркерБезопасности",
			Ложь);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Незаполненные значения заменим пустыми строками для передачи в сервис криптографии.
	Если НЕ ЗначениеЗаполнено(Результат.МаркерБезопасности) Тогда
		Результат.МаркерБезопасности = "";
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Результат.ДлительныйМаркерБезопасности) Тогда
		Результат.ДлительныйМаркерБезопасности = "";
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ВерсияПрограммногоИнтерфейса()
	
	Возврат "v3.1";
	
КонецФункции

Функция НаименованиеКлиента()
	
	Возврат СтрШаблон("%1 (%2):%3", Метаданные.Имя, Метаданные.Версия, Формат(РаботаВМоделиСервиса.ЗначениеРазделителяСеанса(), "ЧГ="));
	
КонецФункции

Функция ПолучитьИменаСвойствДляВосстановления(Метод)
	
	СвойстваДляПреобразования = Новый Массив;
	Если СтрРазделить("crypto/hash", ",").Найти(Метод) <> Неопределено Тогда
		СвойстваДляПреобразования.Добавить("data");
	ИначеЕсли Метод = "crypto/certificate" Тогда
		СвойстваДляПреобразования.Добавить("public_key");
		СвойстваДляПреобразования.Добавить("thumbprint");
		СвойстваДляПреобразования.Добавить("serial_number");
	ИначеЕсли Метод = "crypto/crypto_message" Тогда
		СвойстваДляПреобразования.Добавить("certificates");
		СвойстваДляПреобразования.Добавить("serial_number");
	КонецЕсли;
	
	Возврат СвойстваДляПреобразования;
	
КонецФункции

Функция НайтиСертификат(Сертификат)
	
	СвойстваСертификата = Неопределено;
	Если ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
		СвойстваСертификата = ПолучитьСвойстваСертификата(Сертификат);
	ИначеЕсли (ТипЗнч(Сертификат) = Тип("Структура")
		ИЛИ  ТипЗнч(Сертификат) = Тип("ФиксированнаяСтруктура"))
		И Сертификат.Свойство("Сертификат") Тогда
		СвойстваСертификата = ПолучитьСвойстваСертификата(Сертификат.Сертификат);
	Иначе
		СвойстваСертификата = ХранилищеСертификатов.НайтиСертификат(Сертификат);
	КонецЕсли;
	
	Возврат СвойстваСертификата;
	
КонецФункции

Функция ПолучитьДвоичныеДанныеСертификата(Сертификат)
	
	ДвоичныеДанныеСертификата = Неопределено;
	
	Если ТипЗнч(Сертификат) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеСертификата = ХранилищеСертификатов.СертификатВКодировкеDER(Сертификат);
	ИначеЕсли (ТипЗнч(Сертификат) = Тип("Структура") ИЛИ ТипЗнч(Сертификат) = Тип("ФиксированнаяСтруктура"))
		И Сертификат.Свойство("Сертификат") Тогда
		ДвоичныеДанныеСертификата = ХранилищеСертификатов.СертификатВКодировкеDER(Сертификат.Сертификат);
	Иначе
		ДвоичныеДанныеСертификата = ХранилищеСертификатов.НайтиСертификат(Сертификат).Сертификат;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ДвоичныеДанныеСертификата) Тогда
		ВызватьИсключение(НСтр("ru = 'Не удалось извлечь двоичные данные сертификата'"));
	КонецЕсли;
	
	Возврат ДвоичныеДанныеСертификата;
	
КонецФункции

Функция ПолучитьДвоичныеДанныеСертификатов(Сертификаты)
	
	ДвоичныеДанныеСертификатов = Новый Массив;
	
	Если ТипЗнч(Сертификаты) = Тип("Массив") ИЛИ ТипЗнч(Сертификаты) = Тип("ФиксированныйМассив") Тогда
		МассивСертификатов = Сертификаты;
	Иначе
		МассивСертификатов = Новый Массив;
		МассивСертификатов.Добавить(Сертификаты);
	КонецЕсли;
	
	Для Каждого Сертификат Из МассивСертификатов Цикл 
		ДвоичныеДанныеСертификатов.Добавить(ПолучитьДвоичныеДанныеСертификата(Сертификат));	
	КонецЦикла;
	
	Возврат ДвоичныеДанныеСертификатов;
	
КонецФункции

// Выполнить метод криптосервиса
// 
// Параметры: 
//  Метод - Строка
//  ПараметрыМетода - Структура:
//   * session_key - Строка
//   * ephemeral_key - Строка
//   * data - ДвоичныеДанные
//          - Строка
// 
// Возвращаемое значение:
//  Произвольный
Функция ВыполнитьМетодКриптосервиса(Метод, ПараметрыМетода) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	АдресСервиса = Константы.АдресКриптосервиса.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	ПараметрыСоединения = МенеджерСервисаКриптографии.ПолучитьПараметрыСоединения(АдресСервиса);
	Соединение = ЭлектроннаяПодписьВМоделиСервиса.СоединениеССерверомИнтернета(ПараметрыСоединения);
	
	ЗагрузитьДанныеДляОбработкиНаСервер(Соединение, ПараметрыМетода);
	
	Результат = ВыполнитьМетодСервиса(Соединение, Метод, ПараметрыМетода);
	
	СкачатьРезультатОбработкиССервера(Соединение, Результат);
	
	Возврат Результат;
			
КонецФункции

Процедура ЗагрузитьДанныеДляОбработкиНаСервер(Соединение, ПараметрыМетода)
	
	Для Каждого Параметр Из ПараметрыМетода Цикл
		Если ТипЗнч(Параметр.Значение) = Тип("ДвоичныеДанные") Тогда
			ПараметрыМетода.Вставить(Параметр.Ключ, ОтправитьФайлНаСервер(Соединение, Параметр.Значение)); 
		ИначеЕсли ТипЗнч(Параметр.Значение) = Тип("Массив") Тогда
			Для Индекс = 0 По Параметр.Значение.ВГраница() Цикл
				Параметр.Значение[Индекс] = ОтправитьФайлНаСервер(Соединение, Параметр.Значение[Индекс]);				
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция АдресРесурса(Метод)
	
	Возврат СтрШаблон("/api/%1/%2", ВерсияПрограммногоИнтерфейса(), Метод);
	
КонецФункции

Функция ВызватьHTTPМетод(Соединение, МетодHTTP, Запрос)
	
	Попытка		
		Ответ = Соединение.ВызватьHTTPМетод(МетодHTTP, Запрос);
	Исключение
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Выполнение запроса'", ОбщегоНазначения.КодОсновногоЯзыка()), 
			УровеньЖурналаРегистрации.Ошибка,,,
			КомментарийПоИсключению(
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
				Новый Структура("АдресРесурса", Запрос.АдресРесурса)));	 
		
		ЭлектроннаяПодписьВМоделиСервиса.ВызватьСтандартноеИсключение();
	КонецПопытки;

	Возврат Ответ;
	
КонецФункции

// Параметры: 
//  Соединение - HTTPСоединение
//  Метод - Строка
//  ПараметрыМетода - Структура:
// * ephemeral_key - Строка
// * data - ДвоичныеДанные
// 		  - Строка
// 
// Возвращаемое значение: 
//  Произвольный -Выполнить метод сервиса
Функция ВыполнитьМетодСервиса(Соединение, Метод, ПараметрыМетода)
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	ПараметрыМетода.Вставить("client", НаименованиеКлиента());
	Запрос = Новый HTTPЗапрос(АдресРесурса(Метод), Заголовки);
	Запрос.УстановитьТелоИзСтроки(
		ЭлектроннаяПодписьВМоделиСервиса.СтруктураВJSON(ПараметрыМетода),,
		ИспользованиеByteOrderMark.НеИспользовать);
	
	Ответ = ВызватьHTTPМетод(Соединение, "POST", Запрос);
	
	Если Ответ.КодСостояния <> 200 И Ответ.КодСостояния <> 400 Тогда
		ЗаписатьОшибочныйОтветОтСервисаВЖурналРегистрации(Запрос.АдресРесурса, Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;
		
	ПараметрыПреобразования = Новый Структура;
	Если Ответ.КодСостояния = 200 Тогда
		ПараметрыПреобразования.Вставить("ИменаСвойствДляВосстановления", ПолучитьИменаСвойствДляВосстановления(Метод));
	КонецЕсли;
			
	Результат = ЭлектроннаяПодписьВМоделиСервиса.JsonВСтруктуру(Ответ.ПолучитьТелоКакСтроку(), ПараметрыПреобразования);
	
	Если Результат.status = "success" Тогда		
		Возврат Результат.data;
	ИначеЕсли Результат.status = "fail" Тогда
		ВызватьИсключение(Результат.data);
	КонецЕсли;

КонецФункции

Процедура ЗаписатьОшибкуВЖурналРегистрации(ИмяСобытия, ИнформацияОбОшибке, Параметры) Экспорт
	
	Комментарий = КомментарийПоИсключению(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке), Параметры);
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка,,, Комментарий);
	
КонецПроцедуры

Функция КомментарийПоИсключению(ПредставлениеОшибки, Параметры)
	
	ШаблонЗаписи = 
	"Параметры:
	|%1
	|
	|ПредставлениеОшибки:
	|%2";
	
	Возврат СтрШаблон(
		ШаблонЗаписи, 
		ЭлектроннаяПодписьВМоделиСервиса.СтруктураВJSON(Параметры, Новый Структура("ЗаменятьДвоичныеДанные", Истина)),
		СокрЛП(ПредставлениеОшибки));
		
	КонецФункции
	
Процедура ЗаписатьОшибочныйОтветОтСервисаВЖурналРегистрации(АдресРесурса, ОтветСервера)
	
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Выполнение запроса'", ОбщегоНазначения.КодОсновногоЯзыка()), 
		УровеньЖурналаРегистрации.Ошибка,,,
		КомментарийПоИсключению(ОтветСервера, Новый Структура("АдресРесурса", АдресРесурса)));	 
	
	ЭлектроннаяПодписьВМоделиСервиса.ВызватьСтандартноеИсключение();
	
КонецПроцедуры

Функция ОтправитьФайлНаСервер(Соединение, Файл)
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/octet-stream");
	Запрос = Новый HTTPЗапрос("/upload", Заголовки);
	Запрос.УстановитьТелоИзДвоичныхДанных(Файл);
	
	Ответ = ВызватьHTTPМетод(Соединение, "PUT", Запрос);
	
	Если Ответ.КодСостояния <> 201 Тогда
		ЗаписатьОшибочныйОтветОтСервисаВЖурналРегистрации(Запрос.АдресРесурса, Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;
	
	ИмяФайла = ОбщегоНазначенияБТС.ЗаголовокHTTP(Ответ, "X-New-Name");

	Возврат ИмяФайла;
	
КонецФункции

Функция ПолучитьФайлССервера(Соединение, ИмяФайла)
		
	Заголовки = Новый Соответствие;
	Запрос = Новый HTTPЗапрос("/download/" + ИмяФайла, Заголовки);
	
	Ответ = ВызватьHTTPМетод(Соединение, "GET", Запрос);
	
	Если Ответ.КодСостояния <> 200 Тогда
		ЗаписатьОшибочныйОтветОтСервисаВЖурналРегистрации(Запрос.АдресРесурса, Ответ.ПолучитьТелоКакСтроку());
	КонецЕсли;
	
	Файл = Ответ.ПолучитьТелоКакДвоичныеДанные();

	Возврат Файл;
	
КонецФункции

Процедура СкачатьРезультатОбработкиССервера(Соединение, Параметры)
	
	Если ТипЗнч(Параметры) = Тип("Массив") Тогда
		Для Индекс = 0 По Параметры.ВГраница() Цикл
			Если ТипЗнч(Параметры[Индекс]) = Тип("Строка") И СтрНайти(Параметры[Индекс], "out_") Тогда
				Параметры[Индекс] = ПолучитьФайлССервера(Соединение, Параметры[Индекс]);
			Иначе
				СкачатьРезультатОбработкиССервера(Соединение, Параметры[Индекс]);
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Параметры) = Тип("Структура") Тогда
		Для Каждого Параметр Из Параметры Цикл
			Если ТипЗнч(Параметр.Значение) = Тип("Строка") И СтрНайти(Параметр.Значение, "out_") Тогда
				Параметры.Вставить(Параметр.Ключ, ПолучитьФайлССервера(Соединение, Параметр.Значение));
			Иначе
				СкачатьРезультатОбработкиССервера(Соединение, Параметр.Значение);
			КонецЕсли;
		КонецЦикла; 
	ИначеЕсли ТипЗнч(Параметры) = Тип("Строка") И СтрНайти(Параметры, "out_") Тогда
		Параметры = ПолучитьФайлССервера(Соединение, Параметры);
	КонецЕсли;
		
КонецПроцедуры

Функция ПреобразоватьOID(СписокOID)
	
	Свойства = Новый Структура;
	Для Каждого RDN Из СписокOID Цикл
		Свойства.Вставить(ПолучитьИмяПоOID(RDN.OID), RDN.Value);
	КонецЦикла;
	
	Возврат Новый ФиксированнаяСтруктура(Свойства);
	
КонецФункции

Функция РасширенныеСвойстваСертификата(СписокOID)
	
	EKU = Новый Массив;
	Для Каждого OID Из СписокOID Цикл
		Имя = ПолучитьИмяПоOID(OID, "");
		Если ЗначениеЗаполнено(Имя) Тогда
			EKU.Добавить(СтрШаблон("%1 (%2)", Имя, OID));
		Иначе
			EKU.Добавить(OID);
		КонецЕсли;
	КонецЦикла;

	EKU = Новый ФиксированныйМассив(EKU);
	
	Возврат Новый ФиксированнаяСтруктура(Новый Структура("EKU", EKU));
	
КонецФункции

// Возвращает свойства сертификатов.
// 
// Параметры:
// 	СписокПарСерийныйНомерИздатель - ФиксированныйМассив Из Структура - данные издателя.
// Возвращаемое значение:
// 	Массив Из ФиксированнаяСтруктура - Описание:
//	* СерийныйНомер - Строка - 
//	* Издатель - Строка - 
//	* Идентификатор - Строка - 
Функция ПолучитьСвойстваСертификатовИзJson(СписокПарСерийныйНомерИздатель) Экспорт
	
	Сертификаты = Новый Массив;
	
	Для Каждого Пара Из СписокПарСерийныйНомерИздатель Цикл
		Сертификат = Новый Структура;
		Сертификат.Вставить("СерийныйНомер", Пара.serial_number);
		Сертификат.Вставить("Издатель", ПреобразоватьOID(Пара.issuer));
		Если Пара.Свойство("certificate_id") Тогда
			Сертификат.Вставить("Идентификатор", (Пара.certificate_id));
		КонецЕсли;
		
		Сертификаты.Добавить(Новый ФиксированнаяСтруктура(Сертификат));
	КонецЦикла;
	
	Возврат Сертификаты;

КонецФункции

Функция ПолучитьИмяПоOID(OID, ИмяПоУмолчанию = Неопределено)
	
	Имя = СоответствиеOIDИмя().Получить(OID);
	Если Имя = Неопределено Тогда
		Если ИмяПоУмолчанию <> Неопределено Тогда
			Имя = ИмяПоУмолчанию;
		Иначе
			Имя = "_" + СтрЗаменить(OID, ".", "_");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Имя;
	
КонецФункции

// Готовит соответстие имен и OID в сертификате
//
// Возвращаемое значение:
//	Соответствие
//
Функция СоответствиеOIDИмя()
	
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("2.5.4.3", "CN"); // commonName
	СоответствиеOID.Вставить("2.5.4.6", "C"); // countryName
	СоответствиеOID.Вставить("2.5.4.8", "ST"); // stateOrProvinceName
	СоответствиеOID.Вставить("2.5.4.7", "L"); // localityName
	СоответствиеOID.Вставить("2.5.4.9", "STREET"); // streetAddress
	СоответствиеOID.Вставить("2.5.4.10", "O"); // organizationName
	СоответствиеOID.Вставить("2.5.4.11", "OU"); // organizationUnitName
	СоответствиеOID.Вставить("2.5.4.12", "T"); // title
	СоответствиеOID.Вставить("1.2.643.100.1", "OGRN"); // ОГРН
	СоответствиеOID.Вставить("1.2.643.100.5", "OGRNIP"); // ОГРНИП
	СоответствиеOID.Вставить("1.2.643.100.3", "SNILS"); // СНИЛС
	СоответствиеOID.Вставить("1.2.643.3.131.1.1", "INN"); // ИНН
	СоответствиеOID.Вставить("1.2.643.100.4", "INNLE"); // ИНН ЮЛ
	СоответствиеOID.Вставить("1.2.840.113549.1.9.1", "E"); // emailAddress	
	СоответствиеOID.Вставить("2.5.4.4", "SN"); // surname
	СоответствиеOID.Вставить("2.5.4.42", "GN"); // givenName
	
	Возврат СоответствиеOID;
	
КонецФункции

Функция СоответствиеИмяOID()
	
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("CN", "2.5.4.3"); // commonName
	СоответствиеOID.Вставить("C", "2.5.4.6"); // countryName
	СоответствиеOID.Вставить("ST", "2.5.4.8"); // stateOrProvinceName
	СоответствиеOID.Вставить("L", "2.5.4.7"); // localityName
	СоответствиеOID.Вставить("STREET", "2.5.4.9"); // streetAddress
	СоответствиеOID.Вставить("O", "2.5.4.10"); // organizationName
	СоответствиеOID.Вставить("OU", "2.5.4.11"); // organizationUnitName
	СоответствиеOID.Вставить("T", "2.5.4.12"); // title
	СоответствиеOID.Вставить("OGRN", "1.2.643.100.1"); // ОГРН
	СоответствиеOID.Вставить("OGRNIP", "1.2.643.100.5"); // ОГРНИП
	СоответствиеOID.Вставить("SNILS", "1.2.643.100.3"); // СНИЛС
	СоответствиеOID.Вставить("INN", "1.2.643.3.131.1.1"); // ИНН
	СоответствиеOID.Вставить("INNLE", "1.2.643.100.4"); // ИНН ЮЛ
	СоответствиеOID.Вставить("E", "1.2.840.113549.1.9.1"); // emailAddress	
	СоответствиеOID.Вставить("SN", "2.5.4.4"); // surname
	СоответствиеOID.Вставить("GN", "2.5.4.42"); // givenName
	
	Возврат СоответствиеOID;
	
КонецФункции

// Вычисляет и возвращает идентификатор сертификата.
// 
// Параметры: 
//  СерийныйНомер - Строка
//  Издатель - СписокЗначений из Строка
// 
// Возвращаемое значение:
//  Строка
Функция ВычислитьИдентификаторСертификата(СерийныйНомер, Издатель) Экспорт
	
	СоответствиеИмяOID = СоответствиеИмяOID();
	Для Каждого Элемент Из Издатель Цикл
		Если СоответствиеИмяOID.Получить(Элемент.Представление) <> Неопределено Тогда
			Элемент.Представление = СоответствиеИмяOID.Получить(Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИдентификаторСертификата(СерийныйНомер, Издатель);
	
КонецФункции

Функция ИдентификаторСертификата(СерийныйНомер, СписокOID)
	
	Ключи = СтрРазделить("2.5.4.3,2.5.4.4,2.5.4.6,2.5.4.7,2.5.4.8,2.5.4.10,2.5.4.11,2.5.4.12,2.5.4.42,1.2.840.113549.1.9.1", ",");
	Свойства = Новый СписокЗначений;
	Для Каждого Элемент Из СписокOID Цикл
		Если Ключи.Найти(Элемент.Представление) <> Неопределено Тогда
			Свойства.Добавить(Элемент.Значение, Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	СерийныйНомерСтрока = НРег(СтрЗаменить(СерийныйНомер, " ", ""));
	
	Свойства.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	
	МассивЗначений = Свойства.ВыгрузитьЗначения();
	
	МассивЗначений.Добавить(СерийныйНомерСтрока);
	
	ИздательИСерийныйНомер = СтрСоединить(МассивЗначений, "#");
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(ИздательИСерийныйНомер);
	
	Возврат НРег(СтрЗаменить(Хеширование.ХешСумма, " ", ""));	
	
КонецФункции

Функция ВычислитьИдентификаторСертификатаJson(СвойстваСертификата)
	
	Свойства = Новый СписокЗначений;
	Для Каждого RDN Из СвойстваСертификата.issuer Цикл
		Свойства.Добавить(RDN.value, RDN.oid);
	КонецЦикла;
	
	Возврат ИдентификаторСертификата(СвойстваСертификата.serial_number, Свойства)
	
КонецФункции

Функция ПодготовитьРежимыПроверкиСертификата(РежимыПроверкиСертификата)
	
	МассивСтрок = СтрРазделить(РежимыПроверкиСертификата, ",", Ложь);
	МассивРежимов = Новый Массив;
	Для Каждого СтрокаМассива Из МассивСтрок Цикл
		ТекущееЗначение = НРег(СокрЛП(СтрокаМассива));
		НовоеЗначение = "";
		Если ТекущееЗначение = НРег("ИгнорироватьВремяДействия") Тогда
			НовоеЗначение = "IgnoreTimeValidity";
		ИначеЕсли ТекущееЗначение = НРег("ИгнорироватьДействительностьПодписи") Тогда
			НовоеЗначение = "IgnoreSignatureValidity";
		ИначеЕсли ТекущееЗначение = НРег("ИгнорироватьПроверкуВСпискеОтозванныхСертификатов") Тогда
			НовоеЗначение = "IgnoreCertificateRevocationStatus";
		ИначеЕсли ТекущееЗначение = НРег("РазрешитьТестовыеСертификаты") Тогда
			НовоеЗначение = "AllowTestCertificates";
		Иначе
			НовоеЗначение = СокрЛП(СтрокаМассива);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(НовоеЗначение) Тогда
			МассивРежимов.Добавить(НовоеЗначение);
		КонецЕсли;
		
	КонецЦикла;
	
	Результат = СтрСоединить(МассивРежимов, ",");
	
	Возврат Результат;
	
КонецФункции

#Область ПроверкаВходныхПараметров

Процедура ЗашифроватьПроверкаВходящихПараметров(Данные, Получатели, ТипШифрования, ПараметрыШифрования)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Зашифровать", 
		"Данные",
		Данные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Массив, Строка"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Зашифровать", 
		"Получатели",
		Получатели, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура, ФиксированнаяСтруктура, Массив, ФиксированныйМассив"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Зашифровать", 
		"ТипШифрования",
		ТипШифрования, 
		Новый ОписаниеТипов("Строка"));
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		ТипШифрования = "CMS",
		НСтр("ru = 'Недопустимое значение параметра ТипШифрования (неизвестный тип шифрования)'"), 
		"СервисКриптографии.Зашифровать");
	
	Если ЗначениеЗаполнено(ПараметрыШифрования) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.Зашифровать", 
			"ПараметрыШифрования",
			ПараметрыШифрования, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда 
		ОбщегоНазначенияКлиентСервер.Проверить(
				ЭтоАдресВременногоХранилища(Данные),
				НСтр("ru = 'Недопустимое значение параметра Данные (указан адрес, который не является адресом временного хранилища)'"), 
				"СервисКриптографии.Зашифровать");
	КонецЕсли;	
	Если ТипЗнч(Данные) <> Тип("Массив") Тогда 
		Возврат;
	КонецЕсли;
	
	Индекс = 0;
	Для Каждого Элемент Из Данные Цикл
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.Зашифровать", 
			СтрШаблон("Данные[%1]", Индекс),
			Элемент, 
			Новый ОписаниеТипов("Строка, ДвоичныеДанные"));
		
		Если ТипЗнч(Элемент) = Тип("Строка") Тогда
			ОбщегоНазначенияКлиентСервер.Проверить(
				ЭтоАдресВременногоХранилища(Элемент),
				СтрШаблон(НСтр("ru = 'Недопустимое значение параметра Данные[%1] (указан адрес, который не является адресом временного хранилища)'"), Индекс), 
				"СервисКриптографии.Зашифровать");
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗашифроватьБлокПроверкаВходящихПараметров(Данные, Получатель)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ЗашифроватьБлок", 
		"Данные",
		Данные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ЗашифроватьБлок", 
		"Получатель",
		Получатель, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура, ФиксированнаяСтруктура"));
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда 
		ОбщегоНазначенияКлиентСервер.Проверить(
				ЭтоАдресВременногоХранилища(Данные),
				НСтр("ru = 'Недопустимое значение параметра Данные (указан адрес, который не является адресом временного хранилища)'"), 
				"СервисКриптографии.ЗашифроватьБлок");
	КонецЕсли;	
			
КонецПроцедуры

Процедура РасшифроватьПроверкаВходящихПараметров(ЗашифрованныеДанные, ТипШифрования, ПараметрыШифрования)
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Расшифровать", 
		"ЗашифрованныеДанные",
		ЗашифрованныеДанные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Расшифровать", 
		"ТипШифрования",
		ТипШифрования, 
		Новый ОписаниеТипов("Строка"));
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		ТипШифрования = "CMS",
		НСтр("ru = 'Недопустимое значение параметра ТипШифрования (неизвестный тип шифрования)'"), 
		"СервисКриптографии.Расшифровать");
	
	Если ЗначениеЗаполнено(ПараметрыШифрования) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.Расшифровать", 
			"ПараметрыШифрования",
			ПараметрыШифрования, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
	Если ТипЗнч(ЗашифрованныеДанные) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(ЗашифрованныеДанные),
			НСтр("ru = 'Недопустимое значение параметра ЗашифрованныеДанные (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.Расшифровать");
	КонецЕсли;
		
КонецПроцедуры

Процедура РасшифроватьБлокПроверкаВходящихПараметров(ЗашифрованныеДанные, Получатель, КлючеваяИнформация, ПараметрыШифрования)
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"ЗашифрованныеДанные",
		ЗашифрованныеДанные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"Получатель",
		Получатель, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура, ФиксированнаяСтруктура"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"КлючеваяИнформация",
		КлючеваяИнформация, 
		Новый ОписаниеТипов("Структура"));
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		КлючеваяИнформация.Свойство("ephemeral_key")
		И КлючеваяИнформация.Свойство("iv_data")
		И КлючеваяИнформация.Свойство("session_key"),
		НСтр("ru = 'Отсутствует одно и/или более обязательных свойств параметра КлючеваяИнформация (ephemeral_key|session_key|iv_data)'"), 
		"СервисКриптографии.РасшифроватьБлок");
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"КлючеваяИнформация.ephemeral_key",
		КлючеваяИнформация.ephemeral_key, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"КлючеваяИнформация.session_key",
		КлючеваяИнформация.session_key, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.РасшифроватьБлок", 
		"КлючеваяИнформация.iv_data",
		КлючеваяИнформация.iv_data, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
		
	Если ЗначениеЗаполнено(ПараметрыШифрования) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.РасшифроватьБлок", 
			"ПараметрыШифрования",
			ПараметрыШифрования, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
	Если ТипЗнч(ЗашифрованныеДанные) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(ЗашифрованныеДанные),
			НСтр("ru = 'Недопустимое значение параметра ЗашифрованныеДанные (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.РасшифроватьБлок");
	КонецЕсли;
		
КонецПроцедуры

Процедура ХешированиеДанныхПроверкаВходящихПараметров(Данные, АлгоритмХеширования, ПараметрыХеширования)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ХешированиеДанных", 
		"Данные",
		Данные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(Данные),
			НСтр("ru = 'Недопустимое значение параметра Данные (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.ХешированиеДанных");
	КонецЕсли;
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		СтрРазделить("GOST R 34.11-94^GOST R 34.11-2012 256^GOST R 34.11-2012 512", "^").Найти(АлгоритмХеширования) <> Неопределено,
		НСтр("ru = 'Недопустимое значение параметра АлгоритмХеширования (неизвестный алгоритм хеширования)'"), 
		"СервисКриптографии.ХешированиеДанных");
		
	Если ЗначениеЗаполнено(ПараметрыХеширования) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.ХешированиеДанных", 
			"ПараметрыХеширования",
			ПараметрыХеширования, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
КонецПроцедуры

Процедура ПодписатьПроверкаВходящихПараметров(Данные, Подписант, ТипПодписи, ПараметрыПодписания)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Подписать", 
		"Данные",
		Данные, 
		Новый ОписаниеТипов("ДвоичныеДанные, Массив, Строка"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Подписать", 
		"Подписант",
		Подписант, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура, ФиксированнаяСтруктура"));
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.Подписать", 
		"ТипПодписи",
		ТипПодписи, 
		Новый ОписаниеТипов("Строка"));
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		ТипПодписи = "CMS" ИЛИ ТипПодписи = "GOST3410",
		НСтр("ru = 'Недопустимое значение параметра ТипПодписи (неизвестный тип подписи)'"), 
		"СервисКриптографии.Подписать");
	
	Если ЗначениеЗаполнено(ПараметрыПодписания) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.Подписать", 
			"ПараметрыПодписания",
			ПараметрыПодписания, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда 
		ОбщегоНазначенияКлиентСервер.Проверить(
				ЭтоАдресВременногоХранилища(Данные),
				НСтр("ru = 'Недопустимое значение параметра Данные (указан адрес, который не является адресом временного хранилища)'"), 
				"СервисКриптографии.Подписать");
	КонецЕсли;	
	Если ТипЗнч(Данные) <> Тип("Массив") Тогда 
		Возврат;
	КонецЕсли;
	
	Индекс = 0;
	Для Каждого Элемент Из Данные Цикл
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.Подписать", 
			СтрШаблон("Данные[%1]", Индекс),
			Элемент, 
			Новый ОписаниеТипов("Строка, ДвоичныеДанные"));
		
		Если ТипЗнч(Элемент) = Тип("Строка") Тогда
			ОбщегоНазначенияКлиентСервер.Проверить(
				ЭтоАдресВременногоХранилища(Элемент),
				СтрШаблон(НСтр("ru = 'Недопустимое значение параметра Данные[%1] (указан адрес, который не является адресом временного хранилища)'"), Индекс), 
				"СервисКриптографии.Подписать");
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
		
КонецПроцедуры

Процедура ПроверитьПодписьПроверкаВходящихПараметров(Подпись, Данные, ТипПодписи, ПараметрыПодписания)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПроверитьПодпись", 
		"Подпись",
		Подпись, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	Если ЗначениеЗаполнено(ПараметрыПодписания) Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.ПроверитьПодпись", 
			"ПараметрыПодписания",
			ПараметрыПодписания, 
			Новый ОписаниеТипов("Структура, ФиксированнаяСтруктура"));
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПараметрыПодписания)
		ИЛИ Не ПараметрыПодписания.Свойство("ОтсоединеннаяПодпись")
		ИЛИ Не ПараметрыПодписания.ОтсоединеннаяПодпись Тогда
		ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
			"СервисКриптографии.ПроверитьПодпись", 
			"Данные",
			Данные, 
			Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	КонецЕсли;
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПроверитьПодпись", 
		"ТипПодписи",
		ТипПодписи, 
		Новый ОписаниеТипов("Строка"));
	
	ОбщегоНазначенияКлиентСервер.Проверить(
		ТипПодписи = "CMS" ИЛИ ТипПодписи = "GOST3410",
		НСтр("ru = 'Недопустимое значение параметра ТипПодписи (неизвестный тип подписи)'"), 
		"СервисКриптографии.ПроверитьПодпись");
	
	Если ТипЗнч(Подпись) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(Подпись),
			НСтр("ru = 'Недопустимое значение параметра Подпись (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.ПроверитьПодпись");
	КонецЕсли;
		
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(Данные),
			НСтр("ru = 'Недопустимое значение параметра Данные (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.ПроверитьПодпись");
	КонецЕсли;
	
	Если ТипПодписи = "GOST3410" Тогда 
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЗначениеЗаполнено(ПараметрыПодписания) И ПараметрыПодписания.Свойство("Сертификат"),
			НСтр("ru = 'Для проверки подписи по ГОСТ Р 34.10-94 необходимо указание сертификата'"), 
			"СервисКриптографии.ПроверитьПодпись");
	КонецЕсли;
		
КонецПроцедуры

Процедура ПолучитьСвойстваКриптосообщенияПроверкаВходящихПараметров(Криптосообщение)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьСвойстваКриптосообщения", 
		"Криптосообщение",
		Криптосообщение, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	Если ТипЗнч(Криптосообщение) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(Криптосообщение),
			НСтр("ru = 'Недопустимое значение параметра Криптосообщение (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.ПолучитьСвойстваКриптосообщения");
	КонецЕсли;
		
КонецПроцедуры

Процедура ПолучитьСертификатыИзПодписиПроверкаВходящихПараметров(Подпись)
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьСертификатыИзПодписи", 
		"Подпись",
		Подпись, 
		Новый ОписаниеТипов("ДвоичныеДанные, Строка"));
	
	Если ТипЗнч(Подпись) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			ЭтоАдресВременногоХранилища(Подпись),
			НСтр("ru = 'Недопустимое значение параметра Подпись (указан адрес, который не является адресом временного хранилища)'"), 
			"СервисКриптографии.ПолучитьСертификатыИзПодписи");
	КонецЕсли;
		
КонецПроцедуры

Процедура ПроверитьСертификатПроверкаВходящихПараметров(Сертификат)
		
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПроверитьСертификат", 
		"Сертификат",
		Сертификат, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура"));
		
КонецПроцедуры

Процедура ПолучитьСвойстваСертификатаПроверкаВходящихПараметров(Сертификат)
	
	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьСвойстваСертификата", 
		"Сертификат",
		Сертификат, 
		Новый ОписаниеТипов("ДвоичныеДанные, Структура"));
	
КонецПроцедуры

Процедура ПолучитьВременныйПарольПроверкаВходящихПараметров(ИдентификаторСертификата, ПовторнаяОтправка, СпособДоставкиПаролей)

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьВременныйПароль", 
		"ИдентификаторСертификата",
		ИдентификаторСертификата, 
		Новый ОписаниеТипов("Строка"));

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьВременныйПароль", 
		"ПовторнаяОтправка",
		ПовторнаяОтправка, 
		Новый ОписаниеТипов("Булево"));

	ОбщегоНазначенияКлиентСервер.ПроверитьПараметр(
		"СервисКриптографии.ПолучитьВременныйПароль", 
		"СпособДоставкиПаролей",
		СпособДоставкиПаролей, 
		Новый ОписаниеТипов("Строка"));
		
	Если ТипЗнч(СпособДоставкиПаролей) = Тип("Строка") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			СпособДоставкиПаролей = "phone" ИЛИ СпособДоставкиПаролей = "email",
			НСтр("ru = 'Недопустимое значение параметра СпособДоставкиПаролей, допустимые значения ""phone"" или ""email""'"), 
			"СервисКриптографии.ПолучитьВременныйПароль");
	КонецЕсли;
		
КонецПроцедуры
	
Функция НаименованиеСертификата(СписокOID)
	
	Для Каждого ЭлементOID Из СписокOID Цикл
		Если ЭлементOID.OID = "2.5.4.3" Тогда
			Возврат ЭлементOID.Value;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат "";
	
КонецФункции
	
#КонецОбласти

#Область ИменаСобытий

Функция ИмяСобытияШифрование()
	
	Возврат НСтр("ru = 'Сервис криптографии.Шифрование'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияШифрованиеБлока()
	
	Возврат НСтр("ru = 'Сервис криптографии.Шифрование блока'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияРасшифровка()
	
	Возврат НСтр("ru = 'Сервис криптографии.Расшифровка'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияРасшифровкаБлока()
	
	Возврат НСтр("ru = 'Сервис криптографии.Расшифровка блока'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияАутентификация()
	
	Возврат НСтр("ru = 'Сервис криптографии.Аутентификация'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияСвойстваКриптосообщения()
	
	Возврат НСтр("ru = 'Сервис криптографии.Свойства криптосообщения'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияПроверкаСертификата()
	
	Возврат НСтр("ru = 'Сервис криптографии.Проверка сертификата'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияСвойстваСертификата()
	
	Возврат НСтр("ru = 'Сервис криптографии.Свойства сертификата'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияПроверкаПодписи()
	
	Возврат НСтр("ru = 'Сервис криптографии.Проверка подписи'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияХеширование()
	
	Возврат НСтр("ru = 'Сервис криптографии.Хеширование'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

Функция ИмяСобытияПодписание()
	
	Возврат НСтр("ru = 'Сервис криптографии.Подписание'", ОбщегоНазначения.КодОсновногоЯзыка());
	
КонецФункции

#КонецОбласти

#КонецОбласти